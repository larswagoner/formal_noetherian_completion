import MyProject.AssociatedGradedRing.Map
import Mathlib.RingTheory.MvPolynomial.Homogeneous


import MyProject.am7_6
import MyProject.am10_15
import MyProject.AssociatedGradedRing.Module
import MyProject.AssociatedGradedRing.Components

namespace AssociatedGradedRing

variable {R : Type*} [CommRing R] {A : Type*} [CommRing A] {I : Ideal A} (φ : R →+* AssociatedGradedRing I)

/-- Copyright (c) 2022 Christian Merten-/
lemma Ideal.mem_span_pow' {n : ℕ} (S : Set R) (x : R) :
    x ∈ (Ideal.span S) ^ n ↔ ∃ (p : MvPolynomial S R),
      MvPolynomial.IsHomogeneous p n ∧ MvPolynomial.eval Subtype.val p = x := sorry
/- end of copyright -/


-- first that `A/I[xᵢ] → G(A)` is surjective, using Ideal.mem_span_pow'


-- Okay so mix it all together lmao

def scalar_morphism : GradedRingPiece I 0 →+* AssociatedGradedRing I where
  __ := DirectSum.of _ _
  map_one' := by simp 
  map_mul' := by simp

-- generators of I
/-

def variable_morphism : (vars I) → AssociatedGradedRing I := fun ⟨x, _⟩ => DirectSum.of _ 1 x

def MvMorphism : (AssociatedPolynomialRing I) →+* (AssociatedGradedRing I) := MvPolynomial.eval₂Hom (scalar_morphism I) (variable_morphism I)


lemma MvMorphism_surjective : Function.Surjective ⇑(MvMorphism I) := by
  apply AssociatedGradedRing.hom_surjective_of_eq_of_eq (MvMorphism I)
  · ext x
    simp
    unfold MvMorphism
    use MvPolynomial.C x
    have := MvPolynomial.eval₂Hom_C (scalar_morphism I) (variable_morphism I) x
    exact this
  · ext x
    simp
    have h₁ : x ∈ Submodule.span (GradedRingPiece I 0) (vars I) := by
      unfold vars
      rw [(GradedRingPiece_FG_of_Noetherian I).choose_spec]
      simp
    refine Submodule.span_induction ?_ ?_ ?_ ?_ h₁
    · intro x hx
      use MvPolynomial.X ⟨x, hx⟩
      have := MvPolynomial.eval₂Hom_X' (scalar_morphism I) (variable_morphism I) ⟨x, hx⟩
      unfold MvMorphism
      exact this
    · use 0
      simp
    · intro _ _ _ _ ⟨a , ha⟩ ⟨ b, hb⟩ 
      use a + b
      simp
      rw[ha, hb]
    · intro a x hx ⟨p , hp ⟩
      let a_poly : AssociatedPolynomialRing I := MvPolynomial.C a
      use a_poly * p
      simp
      rw [hp]
      unfold a_poly
      have := MvPolynomial.eval₂Hom_C (scalar_morphism I) (variable_morphism I) a
      congr 1



-/

-- then that `G(A)` as `A/I`-algebra is generated by images of `xᵢ`

-- then prove final lemma

lemma hom_surjective_of_eq_of_eq (h₀ : (DirectSum.of (GradedRingPiece I) 0) ⁻¹' (φ '' ⊤) = ⊤) 
    (h₁ :(DirectSum.of (GradedRingPiece I) 1) ⁻¹' (φ '' ⊤) = ⊤) : Function.Surjective φ := by 

  unfold Function.Surjective
  intro x
  refine DirectSum.induction_on x ?_ ?_ ?_
  · use 0
    simp
  · rintro n
    induction' n using Nat.strong_induction_on with n hn I
    
    
    sorry -- okay, have lemma that says that each of these things can be constructed from lower one. then use that lemma to obtain the goal element in terms of smaller ones, then use the induction hypothesis to obtain elements of a. then use the elements of A and the A linear combination to be done.
    
    /-
    · intro x
      have h₃ : x ∈ (⊤ : Set ((GradedRingPiece I) 0)) := by 
        exact trivial
      rw[← h₀] at h₃
      simp at h₃
      obtain ⟨b, hb⟩ := h₃
      use b
      -/
      
     -- trick is to write goal x as I-linear combination of elements in IH n.
      -- maybe use strong induction and then a homogeneous element of degree n is an A-linear combination of products of elements of lower degrees

    -- hz says that z is in Iⁿ
    
    -- so this y is an element of Iⁿ/Iⁿ⁺¹
    --- I^n can be written as a a finite sum of things I^n-1 over I, for al  n, use induction, work with quotients, pull stuff out. 
    

  · rintro _ _ ⟨a, rfl⟩   ⟨b, rfl⟩ 
    use a + b
    simp
    



end AssociatedGradedRing 