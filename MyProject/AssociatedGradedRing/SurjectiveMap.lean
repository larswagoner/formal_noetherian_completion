import MyProject.AssociatedGradedRing.Map
import Mathlib.RingTheory.MvPolynomial.Homogeneous


import MyProject.am7_6
import MyProject.am10_15
import MyProject.AssociatedGradedRing.Module
import MyProject.AssociatedGradedRing.Components

namespace AssociatedGradedRing

variable {R : Type u} [CommRing R] {A : Type u} [CommRing A] {I : Ideal A} {φ : R →+* AssociatedGradedRing I}

/-- Copyright (c) 2022 Christian Merten-/
lemma Ideal.mem_span_pow' {n : ℕ} (S : Set R) (x : R) :
    x ∈ (Ideal.span S) ^ n ↔ ∃ (p : MvPolynomial S R),
      MvPolynomial.IsHomogeneous p n ∧ MvPolynomial.eval Subtype.val p = x := sorry
/- end of copyright -/

/-
--okey doke, here is the plan. Let vars be a set of generators of I (variable), construct map from polynomial ring to associated graded ring, show that this one is surjective (maybe the map can be given by eval polynomial) using chris' lemma. Then as a corrollary we have finiteness as algebra, then we can deduce main lemma. this is all independent of noetherian ness. so in am_10_22.lean we import this file, and then use as input the finite generating set.

Pracitcally, this lemma wont be used in 10_22.... right? i guess we could keep it, or we could use the surjection from polynomial ring directly... can decide later.

-/


-- first that `A/I[xᵢ] → G(A)` is surjective, using Ideal.mem_span_pow'
universe u v w

variable {vars : Type v} {embedding : vars → GradedRingPiece I 1}  {vars_generate : Submodule.span (GradedRingPiece I 0) (Set.range embedding) = ⊤}

abbrev AssociatedPolynomialRing (I : Ideal A) (vars : Type v) : Type (max u v) := MvPolynomial (vars) (GradedRingPiece I 0)

noncomputable instance : Semiring (AssociatedPolynomialRing I vars) := by
  unfold AssociatedPolynomialRing
  infer_instance

noncomputable instance : CommRing (AssociatedPolynomialRing I vars) := by
  unfold AssociatedPolynomialRing
  infer_instance


def scalar_morphism (I : Ideal A): GradedRingPiece I 0 →+* AssociatedGradedRing I where
  __ := DirectSum.of _ _
  map_one' := by simp 
  map_mul' := by simp

--compose embedding with DirectSum.of
def variable_morphism : (vars) → AssociatedGradedRing I := sorry



-- generators of I
/-

def variable_morphism : (vars I) → AssociatedGradedRing I := fun ⟨x, _⟩ => DirectSum.of _ 1 x

def MvMorphism : (AssociatedPolynomialRing I) →+* (AssociatedGradedRing I) := MvPolynomial.eval₂Hom (scalar_morphism I) (variable_morphism I)


lemma MvMorphism_surjective : Function.Surjective ⇑(MvMorphism I) := by
  apply AssociatedGradedRing.hom_surjective_of_eq_of_eq (MvMorphism I)
  · ext x
    simp
    unfold MvMorphism
    use MvPolynomial.C x
    have := MvPolynomial.eval₂Hom_C (scalar_morphism I) (variable_morphism I) x
    exact this
  · ext x
    simp
    have h₁ : x ∈ Submodule.span (GradedRingPiece I 0) (vars I) := by
      unfold vars
      rw [(GradedRingPiece_FG_of_Noetherian I).choose_spec]
      simp
    refine Submodule.span_induction ?_ ?_ ?_ ?_ h₁
    · intro x hx
      use MvPolynomial.X ⟨x, hx⟩
      have := MvPolynomial.eval₂Hom_X' (scalar_morphism I) (variable_morphism I) ⟨x, hx⟩
      unfold MvMorphism
      exact this
    · use 0
      simp
    · intro _ _ _ _ ⟨a , ha⟩ ⟨ b, hb⟩ 
      use a + b
      simp
      rw[ha, hb]
    · intro a x hx ⟨p , hp ⟩
      let a_poly : AssociatedPolynomialRing I := MvPolynomial.C a
      use a_poly * p
      simp
      rw [hp]
      unfold a_poly
      have := MvPolynomial.eval₂Hom_C (scalar_morphism I) (variable_morphism I) a
      congr 1



-/

-- then that `G(A)` as `A/I`-algebra is generated by images of `xᵢ`

-- then prove final lemma

lemma hom_surjective_of_eq_of_eq (h₀ : (DirectSum.of (GradedRingPiece I) 0) ⁻¹' (φ '' ⊤) = ⊤) 
    (h₁ :(DirectSum.of (GradedRingPiece I) 1) ⁻¹' (φ '' ⊤) = ⊤) : Function.Surjective φ := by 

  unfold Function.Surjective
  intro x
  refine DirectSum.induction_on x ?_ ?_ ?_
  · use 0
    simp
  · rintro n
    induction' n using Nat.strong_induction_on with n hn I
    
    
    sorry -- okay, have lemma that says that each of these things can be constructed from lower one. then use that lemma to obtain the goal element in terms of smaller ones, then use the induction hypothesis to obtain elements of a. then use the elements of A and the A linear combination to be done.
    
    /-
    · intro x
      have h₃ : x ∈ (⊤ : Set ((GradedRingPiece I) 0)) := by 
        exact trivial
      rw[← h₀] at h₃
      simp at h₃
      obtain ⟨b, hb⟩ := h₃
      use b
      -/
      
     -- trick is to write goal x as I-linear combination of elements in IH n.
      -- maybe use strong induction and then a homogeneous element of degree n is an A-linear combination of products of elements of lower degrees

    -- hz says that z is in Iⁿ
    
    -- so this y is an element of Iⁿ/Iⁿ⁺¹
    --- I^n can be written as a a finite sum of things I^n-1 over I, for al  n, use induction, work with quotients, pull stuff out. 
    

  · rintro _ _ ⟨a, rfl⟩   ⟨b, rfl⟩ 
    use a + b
    simp
    



end AssociatedGradedRing 