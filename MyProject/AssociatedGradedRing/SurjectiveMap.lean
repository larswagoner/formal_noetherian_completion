import MyProject.AssociatedGradedRing.Map
import Mathlib.RingTheory.MvPolynomial.Homogeneous


import MyProject.am7_6
import MyProject.am10_15
import MyProject.AssociatedGradedRing.Module
import MyProject.AssociatedGradedRing.Components

namespace AssociatedGradedRing

variable {R : Type u} [CommRing R] {A : Type u} [CommRing A] {I : Ideal A} {φ : R →+* AssociatedGradedRing I}

/-- Copyright (c) 2022 Christian Merten-/
lemma Ideal.mem_span_pow' {n : ℕ} (S : Set R) (x : R) :
    x ∈ (Ideal.span S) ^ n ↔ ∃ (p : MvPolynomial S R),
      MvPolynomial.IsHomogeneous p n ∧ MvPolynomial.eval Subtype.val p = x := sorry
/- end of copyright -/

/-
--okey doke, here is the plan. Let vars be a set of generators of I (variable), construct map from polynomial ring to associated graded ring, show that this one is surjective (maybe the map can be given by eval polynomial) using chris' lemma. Then as a corrollary we have finiteness as algebra, then we can deduce main lemma. this is all independent of noetherian ness. so in am_10_22.lean we import this file, and then use as input the finite generating set.

Pracitcally, this lemma wont be used in 10_22.... right? i guess we could keep it, or we could use the surjection from polynomial ring directly... can decide later.

-/


/- SECTION I -/
universe u v w

variable {vars : Type v} {embedding : vars → GradedRingPiece I 1}  {vars_generate : Submodule.span (GradedRingPiece I 0) (Set.range embedding) = ⊤}

abbrev AssociatedPolynomialRing (I : Ideal A) (vars : Type v) : Type (max u v) := MvPolynomial (vars) (GradedRingPiece I 0)

noncomputable instance : Semiring (AssociatedPolynomialRing I vars) := by
  unfold AssociatedPolynomialRing
  infer_instance

noncomputable instance : CommRing (AssociatedPolynomialRing I vars) := by
  unfold AssociatedPolynomialRing
  infer_instance


def scalar_morphism (I : Ideal A): GradedRingPiece I 0 →+* AssociatedGradedRing I where
  __ := DirectSum.of _ _
  map_one' := by simp 
  map_mul' := by simp

def variable_morphism (embedding : vars → GradedRingPiece I 1): (vars) → AssociatedGradedRing I := DirectSum.of _ 1 ∘ embedding

def MvMorphism (I : Ideal A) (vars : Type v) (embedding : vars → GradedRingPiece I 1) : 
    (AssociatedPolynomialRing I (vars)) →+* (AssociatedGradedRing I) := 
      MvPolynomial.eval₂Hom (scalar_morphism I) (variable_morphism embedding)

/-- `A/I[xᵢ] → G(A)` is surjective -/
lemma MvMorphism.Surjective (I : Ideal A) (vars : Type v) (embedding : vars → GradedRingPiece I 1) : Function.Surjective ⇑(MvMorphism I vars embedding) := by
  unfold Function.Surjective
  sorry 


/- SECTION II -/

-- maybe define this in terms
instance : Algebra (GradedRingPiece I 0) (AssociatedGradedRing I) where
  smul a x := (scalar_morphism I a)*x
  algebraMap := scalar_morphism I
  commutes' r x := CommMonoid.mul_comm ((scalar_morphism I) r) x
  smul_def' _ _ := rfl


/-- `G(A)` as `A/I`-algebra is generated by images of `xᵢ` -/
lemma AssociatedGradedRing_generated : Algebra.adjoin (GradedRingPiece I 0) (Set.range (variable_morphism embedding)) = ⊤ := by
  ext x
  simp
  have ⟨a, ha⟩ := MvMorphism.Surjective I vars embedding x
  rw[← ha]
  unfold MvMorphism
  simp


  sorry



/- SECTION III -/
lemma hom_surjective_of_eq_of_eq (h₀ : (DirectSum.of (GradedRingPiece I) 0) ⁻¹' (φ '' ⊤) = ⊤) 
    (h₁ :(DirectSum.of (GradedRingPiece I) 1) ⁻¹' (φ '' ⊤) = ⊤) : Function.Surjective φ := by

  unfold Function.Surjective
  intro b   
  
      
  sorry
    



end AssociatedGradedRing 