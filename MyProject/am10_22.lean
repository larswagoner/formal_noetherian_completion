import MyProject.am7_6
import MyProject.am10_15
import MyProject.AssociatedGradedRing.Module
import MyProject.AssociatedGradedRing.SurjectiveMap
import MyProject.AssociatedGradedRing.Components
import MyProject.AssociatedGradedRing.Algebra

/-
  # Proposition 10.22
  Let `A` be a Noetherian ring and `a` an ideal of `A`. Then
  i) `Gₐ(A)` is Noetherian.
  ii) `Gₐ(A)` and `Gₐ(Â)` are isomorphic as graded rings.
  iii) If `M` is a finitely-generated `A`-module and `(Mₙ)` is a stable `a`-filtration of `M`,
      then `G(M)` is a finitely-generated graded `Gₐ(A)`-module.
-/

variable {A : Type u} [CommRing A] [hNA: IsNoetherianRing A] (I : Ideal A) {R : Type u} [CommRing R]


-- start scratch 
-- Gives Finset I lemma ideal_fg : (⊤ : Submodule A I).FG := Module.Finite.fg_top

-- define φ on homogeneous components? then the desired equ


-- APPROACH 3

/-- Copyright (c) 2022 Christian Merten-/
lemma Ideal.mem_span_pow' {n : ℕ} (S : Set R) (x : R) :
    x ∈ (Ideal.span S) ^ n ↔ ∃ (p : MvPolynomial S R),
      MvPolynomial.IsHomogeneous p n ∧ MvPolynomial.eval Subtype.val p = x := sorry
/- end of copyright -/

def ideal_fg := (IsNoetherian.noetherian I) 

noncomputable def ideal_generators : Set A:= (ideal_fg I).choose



abbrev aux_polynomial (I : Ideal A) := MvPolynomial (ideal_generators I) A

instance : IsNoetherianRing (aux_polynomial I) := by
  dsimp [aux_polynomial, ideal_generators]
  infer_instance


def scalars₁_aux : A →+ (CanonicalFiltration I).N 0 := by exact zero_toFun_aux₁ I

def scalars₁ : A →+* GradedRingPiece I 0 where
  toFun := Submodule.Quotient.mk ∘ scalars₁_aux I
  map_one' := rfl
  map_mul' _ _ := rfl
  map_zero' := rfl
  map_add' _ _ := rfl

def scalar_morph : A →+* AssociatedGradedRing I where
  toFun := DirectSum.of _ 0 ∘ scalars₁ I
  map_one' := rfl
  map_mul' _ _ := by simp
  map_zero' := by simp
  map_add' _ _ := by simp



def ideal_generator_mem (a : A) (ha: a ∈ ideal_generators I) : a ∈ I := by
  have : Submodule.span A (ideal_generators I) = I := (IsNoetherian.noetherian I).choose_spec
  rw[← this] 
  exact Submodule.mem_span.mpr fun p a_1 ↦ a_1 ha


--def var₁ (a : A) (ha: a ∈ ideal_generators I) :  I :=  ⟨a, ideal_generator_mem I a ha⟩

   --exact Submodule.mem_span.mpr fun p a_1 ↦ a_1 ha

def oneaux₁ : ideal_generators I → ↥(I) := fun ⟨a, ha⟩ => ⟨a, ideal_generator_mem I a ha⟩

def oneaux₂ : ↥(I) → (CanonicalFiltration I).N 1 := fun x => ⟨x, by simp⟩

def oneaux₃ : (CanonicalFiltration I).N 1 → AssociatedGradedRing I :=  DirectSum.of _ 1 ∘ Submodule.Quotient.mk 
  
def var_morph : ideal_generators I → AssociatedGradedRing I := fun x =>  ((oneaux₃ I) ∘ (oneaux₂ I) ∘ (oneaux₁ I)) x





-- MvPolynomal.aeval (var_morph I)

def φ₂ (I : Ideal A): aux_polynomial I →ₐ[A] AssociatedGradedRing I :=   MvPolynomial.eval₂Hom (scalar_morph I) (var_morph I)

def φ (I : Ideal A): aux_polynomial I →+* AssociatedGradedRing I :=   MvPolynomial.eval₂Hom (scalar_morph I) (var_morph I)


lemma φ.Surjective : Function.Surjective (φ I) := by
  intro x
  refine DirectSum.induction_on x ?_ ?_ ?_
  · use 0
    simp
  · rintro n ⟨y⟩ 
    
    sorry
  · rintro x y ⟨a, ha⟩ ⟨b, hb⟩
    use a+b
    rw [map_add, ha, hb]


instance am10_22_i {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A] : IsNoetherianRing (AssociatedGradedRing I) := by 
  exact isNoetherianRing_of_surjective (aux_polynomial I) (AssociatedGradedRing I) (φ I) (φ.Surjective I)




/-
  Note, `I.adicCompletion I` is the `Â`-ideal generated by `I`.
-/

def aux4 (ι : Type*)  (α : ι → Type*) [(i : ι) → AddCommMonoid (α i)]  (β : ι → Type*) [(i : ι) → AddCommMonoid (β i)] : (∀ (i : ι), α i ≃+ β i) → (DirectSum ι α)  ≃+ (DirectSum ι β) := sorry

def aux5 (n:ℕ): (GradedPiece (CanonicalFiltration I) n) ≃+ (GradedPiece (CanonicalFiltration (I.adicCompletion I)) n) := sorry -- use am10_15_iii


/- Need to define AdicCompletion.instCommRing in adic_completion.lean
def aux6 {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A] :
  (AssociatedGradedRing I) ≃+ (AssociatedGradedRing (I.adicCompletion I)) := aux4 ℕ (fun n ↦ GradedPiece (CanonicalFiltration I) n) (fun n ↦ GradedPiece (CanonicalFiltration (I.adicCompletion I)) n) fun i ↦ aux5 I i 
-/
  

def am10_22_ii {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A] :
  (AssociatedGradedRing I) ≃+* (AssociatedGradedRing (I.adicCompletion I)) := by 
  -- use aux6 above, then prove compatibility with multiplication.
  sorry

instance am10_22_iii {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A]
  {M : Type u} [AddCommGroup M] [Module A M] [Module.Finite A M]
  {F : I.Filtration M} (hF : F.Stable) :
    Module.Finite (AssociatedGradedRing I) (AssociatedGradedModule F) := sorry