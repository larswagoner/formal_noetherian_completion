import MyProject.am7_6
import MyProject.am10_15
import MyProject.AssociatedGradedRing.Module

/-
  # Proposition 10.22
  Let `A` be a Noetherian ring and `a` an ideal of `A`. Then
  i) `Gₐ(A)` is Noetherian.
  ii) `Gₐ(A)` and `Gₐ(Â)` are isomorphic as graded rings.
  iii) If `M` is a finitely-generated `A`-module and `(Mₙ)` is a stable `a`-filtration of `M`,
      then `G(M)` is a finitely-generated graded `Gₐ(A)`-module.
-/

/- LARS COMMENTS: delete before pushing to master
-- how to get generators? map them to I/I^2 (F.N 2 or 1) via some canonical map. Then how to get from that to quotient. Maybe A/I noetherian is easy, then A/I [y₁, ..., yₙ] as polynomial ring is noetherian. Then define map out of that with kernel the generators, expressing graded as quotient, hence noetherian via isomorphism.  For map, just need surjection from polynomial to Graded, then noetherian follows. 

-- theorem isNoetherian_of_surjective
-- what is the map though... A/I [X] → G(A)
-- i need a max of the number of generators.... 

-- maybe dont care about the n, just extract the S from I.FG. Then use algebra adjoin A/I S. Is this a ring structure?
-- maybe given a and I , i make a function that outputs A/I[x,...,x] either as polynomial or with S. 
-/

variable {A : Type u} [CommRing A] [hNA: IsNoetherianRing A] (I : Ideal A)

--noncomputable instance : DecidableEq (A ⧸ I) := fun a b ↦ Classical.propDecidable (a = b)
--noncomputable instance : Algebra (A ⧸ I) (A ⧸ I) := Algebra.id (A ⧸ I)

/- Given an ideal I, returns Polynomial ring over A/I with variables indexed by 
generators of I. Finitely many since A noetherian-/
noncomputable def ideal_to_MvPolynomial : Type u := (MvPolynomial (((isNoetherianRing_iff_ideal_fg A).mp) hNA I).choose (A ⧸ I))

/- Polynomial ring is Noetherian-/
noncomputable instance : Semiring (ideal_to_MvPolynomial I) := by
  unfold ideal_to_MvPolynomial
  infer_instance

noncomputable instance : IsNoetherianRing (ideal_to_MvPolynomial I) := by
  unfold ideal_to_MvPolynomial
  infer_instance

-- Map from Poly to Graded ring -- https://leanprover-community.github.io/mathlib4_docs/Mathlib/Algebra/MvPolynomial/Eval.html#MvPolynomial.eval%E2%82%82
noncomputable def MvPolynomial_to_AssociatedGradedRing : (ideal_to_MvPolynomial I) → (AssociatedGradedRing I) := sorry

noncomputable def MvMorphism : (ideal_to_MvPolynomial I) →+* (AssociatedGradedRing I) := sorry

lemma MvMorphism_surjective : Function.Surjective ⇑(MvMorphism I) := sorry




instance am10_22_i {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A] :
  IsNoetherianRing (AssociatedGradedRing I) := isNoetherianRing_of_surjective (ideal_to_MvPolynomial I) (AssociatedGradedRing I) (MvMorphism I) (MvMorphism_surjective I)


  

/-
  Note, `I.adicCompletion I` is the `Â`-ideal generated by `I`.
-/

def am10_22_ii {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A] :
  (AssociatedGradedRing I) ≃+* (AssociatedGradedRing (I.adicCompletion I)) := sorry

instance am10_22_iii {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A]
  {M : Type u} [AddCommGroup M] [Module A M] [Module.Finite A M]
  {F : I.Filtration M} (hF : F.Stable) :
    Module.Finite (AssociatedGradedRing I) (AssociatedGradedModule F) := sorry
