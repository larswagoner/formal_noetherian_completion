import MyProject.am7_6
import MyProject.am10_15
import MyProject.AssociatedGradedRing.Module

/-
  # Proposition 10.22
  Let `A` be a Noetherian ring and `a` an ideal of `A`. Then
  i) `Gₐ(A)` is Noetherian.
  ii) `Gₐ(A)` and `Gₐ(Â)` are isomorphic as graded rings.
  iii) If `M` is a finitely-generated `A`-module and `(Mₙ)` is a stable `a`-filtration of `M`,
      then `G(M)` is a finitely-generated graded `Gₐ(A)`-module.
-/


-- how to get generators? map them to I/I^2 (F.N 2 or 1) via some canonical map. Then how to get from that to quotient. Maybe A/I noetherian is easy, then A/I [y₁, ..., yₙ] as polynomial ring is noetherian. Then define map out of that with kernel the generators, expressing graded as quotient, hence noetherian via isomorphism.  For map, just need surjection from polynomial to Graded, then noetherian follows. 

-- theorem isNoetherian_of_surjective
-- what is the map though... A/I [X] → G(A)
-- i need a max of the number of generators.... 


instance am10_22_i {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A] :
  IsNoetherianRing (AssociatedGradedRing I) := by
  
  
  sorry

/-
  Note, `I.adicCompletion I` is the `Â`-ideal generated by `I`.
-/

-- really this is a corollary of am10_22_ii
def am10_22_ii {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A] :
  (AssociatedGradedRing I) ≃+* (AssociatedGradedRing (I.adicCompletion I)) := sorry

instance am10_22_iii {A : Type u} [CommRing A] (I : Ideal A) [IsNoetherianRing A]
  {M : Type u} [AddCommGroup M] [Module A M] [Module.Finite A M]
  {F : I.Filtration M} (hF : F.Stable) :
    Module.Finite (AssociatedGradedRing I) (AssociatedGradedModule F) := sorry
