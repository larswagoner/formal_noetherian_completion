import MyProject.am1_9
import MyProject.am10_4
import MyProject.am10_5
import MyProject.am10_13


/-
  # Proposition 10.15
  Let `A` be a Noetherian ring, and `Â` its `a`-adic completion. Then
  i) `â = Âa ≅ Â ⨂ a`.
  ii) `(aⁿ)^ = (â)ⁿ`.
  iii) `aⁿ/aⁿ⁺¹ ≅ âⁿ/âⁿ⁺¹`.
  iv) `â` is contained in the Jacobson radical of `Â`.
-/

variable {A : Type*} [CommRing A] (I : Ideal A)

/-
  Given an ideal `J ⊆ A`, this gives the ideal `J^ = Â • J` in `Â`.
-/


variable [IsNoetherianRing A]

-- get induced map AdicCompletion I I → AdicCompletion I A (inclusion), show image is I.adicCompletion I

-- Note:
-- Option 1) We take `â` to be the `a`-adic completion of `a`. This makes it an `Â`-module.
-- Option 2) We take `â` to be the ideal in `Â` generated by `a`. This gives it an `Â`-ideal
-- structure. Which one should we use?


noncomputable def am10_15_i_option_1 :
    AdicCompletion I I ≃ₗ[AdicCompletion I A] TensorProduct A (AdicCompletion I A) I :=
  (AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I I).symm



noncomputable def am10_15_i_option_2 : I.adicCompletion I  ≃ₗ[AdicCompletion I A] TensorProduct A (AdicCompletion I A) I := sorry



noncomputable def am10_15_ii (n : ℕ) :(I.adicCompletion I)^n = I.adicCompletion (I^n) := id (Eq.symm (Ideal.map_pow (algebraMap A (AdicCompletion I A)) I n))

section

variable {M : Type v} [AddCommGroup M] [Module A M]

-- This should now be possible: use 10_5 and that Î = Â • I
/--
  Important lemma: define two subgroups `G₁`, `G₂` of `Â` by:
  (1) Let `G₁ ⊆ Â` be the ideal generated by the image of the composition `I → A → Â`.
  (2) Let `G₂ ⊆ Â` be the image of the composition `I → Î → Â`, where the first map is the completion map.
  Then `G₁ = G₂`.
-/
lemma aux₁ (n : ℕ) : ((I.adicCompletion I)^n).toAddSubgroup =
  (AddSubgroupCompletion ((I.stableFiltration ⊤).toOurFiltration.N n) (I.stableFiltration (⊤ : Submodule A A)).toOurFiltration) := sorry

instance : IsAdicComplete (I.adicCompletion I) (AdicCompletion I M) := by
  rw [isComplete_iff_isCanonicalOurComplete]
  have := am10_5' (I.stableFiltration (⊤ : Submodule A A)).toOurFiltration
  convert this
  sorry
  -- ext n x
  -- unfold CompletedFiltration
  -- simp
  -- rw [←aux₁ I n]
  -- dsimp [Ideal.stableFiltration, Ideal.Filtration.toOurFiltration]
  -- simp

end

noncomputable def am10_15_iii_map (n : ℕ) {A: Type*} [CommRing A] (I : Ideal A) [hN : IsNoetherianRing A] : -- apply one of the isomorphism theorems
    (↥(I^n)⧸(I•⊤ : Submodule A ↥(I^n))) →+ (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))) := sorry

lemma am10_15_iii (n : ℕ) : Function.Bijective (am10_15_iii_map n I) := sorry

noncomputable def test :  (↥(I^n)⧸(I•⊤ : Submodule A ↥(I^n))) ≃+ (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))) := by
  sorry


omit [IsNoetherianRing A] in -- It is not necerssary for `A` to be Noetherian.
lemma am10_15_iv : (I.adicCompletion I) ≤ (⊥ : Ideal (AdicCompletion I A)).jacobson :=
  IsAdicComplete.le_jacobson_bot (I.adicCompletion I)
