import MyProject.am1_9
import MyProject.am10_4
import MyProject.am10_5
import MyProject.am10_13

/-
  # Proposition 10.15
  Let `A` be a Noetherian ring, and `Â` its `a`-adic completion. Then
  i) `â = Âa ≅ Â ⨂ a`.
  ii) `(aⁿ)^ = (â)ⁿ`.
  iii) `aⁿ/aⁿ⁺¹ ≅ âⁿ/âⁿ⁺¹`.
  iv) `â` is contained in the Jacobson radical of `Â`.
-/

variable {A : Type*} [CommRing A] (I : Ideal A)

/-
  Given an ideal `J ⊆ A`, this gives the ideal `J^ = Â • J` in `Â`.
-/
def adicCompletionIdeal_ofIdeal (J : Ideal A) : Ideal (AdicCompletion I A) := 
  sorry -- will probably have to be noncomputable due to adic completion

noncomputable def Ideal.adicCompletion (J : Ideal A): Ideal (AdicCompletion I A) := Ideal.map (algebraMap _ _) J -- extension of J into I-adic completion via induced algebra map. This is option 2 below. "I adic completion of J = I.adicCompletion J"

variable [IsNoetherianRing A]

-- Note:
-- Option 1) We take `â` to be the `a`-adic completion of `a`. This makes it an `Â`-module.
-- Option 2) We take `â` to be the ideal in `Â` generated by `a`. This gives it an `Â`-ideal
-- structure. Which one should we use?
-- Option 3) Endow ring structure on option 1, show isomorphic (equal?) to ideal from option 2. Probably the best way to go about it.

noncomputable def am10_15_i_option_1 :
    AdicCompletion I I ≃ₗ[AdicCompletion I A] TensorProduct A (AdicCompletion I A) I :=
  (AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I I).symm

noncomputable def am10_15_i_option_2 :
    adicCompletionIdeal_ofIdeal I I ≃ₗ[AdicCompletion I A] TensorProduct A (AdicCompletion I A) I := sorry

noncomputable def am10_15_i_option_2_b : I.adicCompletion I  ≃ₗ[AdicCompletion I A] TensorProduct A (AdicCompletion I A) I := by
  sorry



noncomputable def am10_15_ii (n : ℕ) :(I.adicCompletion I)^n = I.adicCompletion (I^n) := by
  
  sorry


noncomputable def am10_15_iii_map (n : ℕ) {A: Type*} [CommRing A] (I : Ideal A) [hN : IsNoetherianRing A] :  -- uses option 2 for I hat
    (↥(I^n)⧸(I•⊤ : Submodule A ↥(I^n))) → (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))) := sorry

lemma am10_15_iii (n : ℕ) : Function.Bijective (am10_15_iii_map n I) := sorry


lemma am10_15_iv : true := sorry 
