import MyProject.am1_9
import MyProject.am10_4
import MyProject.am10_5
import MyProject.am10_13
import MyProject.AssociatedGradedRing.Ring

/-
  # Proposition 10.15
  Let `A` be a Noetherian ring, and `Â` its `a`-adic completion. Then
  i) `â = Âa ≅ Â ⨂ a`.
  ii) `(aⁿ)^ = (â)ⁿ`.
  iii) `aⁿ/aⁿ⁺¹ ≅ âⁿ/âⁿ⁺¹`.
  iv) `â` is contained in the Jacobson radical of `Â`.
-/

variable {A : Type*} [CommRing A] (I : Ideal A) [IsNoetherianRing A]

/-
  The ideal in `AdicCompletion I A` generated by an ideal `J ⊆ A` is the same as the image of the composition
  `Â ⨂ I → Â ⨂ A → Â`.
-/
omit [IsNoetherianRing A] in
lemma Ideal.adicCompletion_eq_tensor_product_range (J : Ideal A) :
  I.adicCompletion J = LinearMap.range
    (AdicCompletion.ofTensorProduct I A ∘ₗ TensorProduct.AlgebraTensorModule.map LinearMap.id J.subtype) := by
  apply le_antisymm
  · apply Ideal.map_le_of_le_comap
    intro y hy
    rw [Ideal.mem_comap]
    show AdicCompletion.of I A y ∈ _
    use TensorProduct.mk _ _ _ 1 ⟨y, hy⟩
    simp
  · rintro x ⟨y, rfl⟩
    refine TensorProduct.induction_on y ?_ ?_ ?_
    · simp
    · intro x y
      simp
      apply Ideal.mul_mem_left
      apply Ideal.apply_coe_mem_map
    · intro x y hx hy
      simp
      exact Submodule.add_mem _ hx hy

/--
  Let `J ⊆ A` be an ideal. Then the ideal in `Â` generated by `J` is equal to the image of the
  map `J^ → Â`, where `J^` is the completion of `J` by pulling back a filtration along `J → A`.
-/
lemma am10_15_i (J : Ideal A) :
  (I.adicCompletion J).toAddSubgroup =
    AddSubgroupCompletion J.toAddSubgroup (CanonicalFiltration I).toOurFiltration := by
  let R := TensorProduct A (AdicCompletion I A) J
  let Jc := AdicCompletion I J
  let Ac := AdicCompletion I A

  let f : R ≃ₗ[AdicCompletion I A] Jc := AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I J
  let g : Jc →ₗ[AdicCompletion I A] Ac := AdicCompletion.map I (J.subtype)
  let h : R →ₗ[AdicCompletion I A] Ac := AdicCompletion.ofTensorProduct I A ∘ₗ TensorProduct.AlgebraTensorModule.map LinearMap.id J.subtype
  have comm : g ∘ₗ f = h := AdicCompletion.ofTensorProduct_naturality I J.subtype

  have h₁ : I.adicCompletion J = LinearMap.range h := Ideal.adicCompletion_eq_tensor_product_range I J
  have h₂ : AddSubgroupCompletion J.toAddSubgroup (CanonicalFiltration I).toOurFiltration = g.toAddMonoidHom.range := sorry

  rw [h₁, h₂]
  rw [←comm]
  simp
  rfl

lemma am10_15_ii_option_2 (n : ℕ) :
  ((I.adicCompletion I)^n).toAddSubgroup =
    (CompletedFiltration (CanonicalFiltration I).toOurFiltration).N n := by
  have : (I.adicCompletion I)^n = I.adicCompletion (I^n) := (I.map_pow (algebraMap A (AdicCompletion I A)) n).symm
  rw [this]
  dsimp [CompletedFiltration]
  convert am10_15_i I (I^n)
  dsimp [CanonicalFiltration, Ideal.stableFiltration]
  show (I^ n • (⊤ : Submodule A A)).toAddSubgroup =  (I ^ n).toAddSubgroup
  congr
  simp

lemma am10_15_ii (n : ℕ) :
  ((CanonicalFiltration (I.adicCompletion I)).N n).toAddSubgroup =
    (CompletedFiltration (CanonicalFiltration I).toOurFiltration).N n := by
  rw [←am10_15_ii_option_2]
  simp

section

variable {M : Type v} [AddCommGroup M] [Module A M]

/--
  The `I`-adic completion of a ring `A` is `Î`-adic complete.
-/
instance [IsNoetherianRing A] : IsAdicComplete (I.adicCompletion I) (AdicCompletion I A) := by
  rw [isComplete_iff_isCanonicalOurComplete]
  have := am10_5₂ (I.stableFiltration (⊤ : Submodule A A)).toOurFiltration
  convert this
  ext n x
  rw [←am10_15_ii]
  rfl

end

lemma mem_canonical_n_iff_mem_completed_canonical_n (n : ℕ) (x : A) :
  x ∈ (CanonicalFiltration I).N n ↔
    (OurFiltrationCompletion.of (CanonicalFiltration I).toOurFiltration) x ∈ (CanonicalFiltration (I.adicCompletion I)).N n := by
  show _ ∈ (CanonicalFiltration I).toOurFiltration.N n ↔ _ ∈ ((CanonicalFiltration (I.adicCompletion I)).N n).toAddSubgroup
  rw [am10_15_ii]
  rw [mem_n_iff_completion_mem_n]

def am10_15_iii_aux₁ (n : ℕ) :
    (CanonicalFiltration I).N n →+ (CanonicalFiltration (I.adicCompletion I)).N n where
  toFun := by
    intro ⟨x, hx⟩
    exact ⟨OurFiltrationCompletion.of (CanonicalFiltration I).toOurFiltration x,
      (mem_canonical_n_iff_mem_completed_canonical_n I n x).mp hx⟩
  map_zero' := by simp
  map_add' := by simp

noncomputable def am10_15_iii_aux₂ (n : ℕ) :
    GradedRingPiece I n →+ GradedRingPiece (I.adicCompletion I) n :=
  QuotientAddGroup.map _ _ (am10_15_iii_aux₁ I n) (by
      intro ⟨x, hx⟩ h
      exact (mem_canonical_n_iff_mem_completed_canonical_n I (n+1) x).mp h
    )

lemma am10_15_iii_aux₂_apply (n : ℕ) (x : (CanonicalFiltration I).N n) :
  am10_15_iii_aux₂ I n ⟦x⟧ = ⟦⟨OurFiltrationCompletion.of (CanonicalFiltration I).toOurFiltration x.1, (mem_canonical_n_iff_mem_completed_canonical_n I n x.1).mp x.2⟩⟧ := rfl

/-
  Note: this can probably be proven in a nicer way, as we have a commutative diagram
  0 -> Iⁿ/Iⁿ⁺¹ → A/Iⁿ⁺¹ → A/Iⁿ → 0
         |        |        |
  0 -> Iⁿ/Iⁿ⁺¹ → A/Iⁿ⁺¹ → A/Iⁿ → 0
  and the middle and right vertical maps are isos, and so the left one must be as well.
-/
noncomputable def am10_15_iii (n : ℕ) :
    GradedRingPiece I n ≃+ GradedRingPiece (I.adicCompletion I) n :=
  AddEquiv.ofBijective (am10_15_iii_aux₂ I n) (by
    constructor
    · apply (injective_iff_map_eq_zero (am10_15_iii_aux₂ I n)).mpr
      rintro ⟨a, ha⟩ h
      apply (QuotientAddGroup.eq_zero_iff _).mpr
      apply (mem_canonical_n_iff_mem_completed_canonical_n _ _ _).mpr
      show (OurFiltrationCompletion.of (CanonicalFiltration I).toOurFiltration a) ∈ (CanonicalFiltration (I.adicCompletion I)).N (n + 1)
      exact (QuotientAddGroup.eq_zero_iff _).mp h
    · rintro ⟨x, hx⟩
      have := (am10_4 (CanonicalFiltration I).toOurFiltration (n+1)).surjective
      rcases (this x) with ⟨y, h⟩
      have : y.out ∈ (CanonicalFiltration I).N n
      · rw [mem_canonical_n_iff_mem_completed_canonical_n]
        apply (Submodule.sub_mem_iff_left _ hx).mp
        apply (CanonicalFiltration (I.adicCompletion I)).mono n
        show _ ∈ ((CanonicalFiltration (I.adicCompletion I)).N (n+1)).toAddSubgroup
        rw [am10_15_ii]
        apply QuotientAddGroup.eq_iff_sub_mem.mp
        rw [←Quotient.out_eq y] at h
        rw [am10_4_apply] at h
        exact h
      use ⟦⟨y.out, this⟩⟧ₘ
      rw [←Quotient.out_eq y] at h
      rw [am10_4_apply] at h
      rw [am10_15_iii_aux₂_apply]
      show QuotientAddGroup.mk _ = QuotientAddGroup.mk _
      refine QuotientAddGroup.eq_iff_sub_mem.mpr ?_
      show _ - x ∈ ((CanonicalFiltration (I.adicCompletion I)).N (n + 1)).toAddSubgroup
      rw [am10_15_ii]
      rw [←QuotientAddGroup.eq_iff_sub_mem]
      exact h
  )

lemma am10_15_iii_commute (m n : ℕ) (x : GradedRingPiece I m) (y : GradedRingPiece I n) :
    am10_15_iii I (m + n) (graded_mul x y) = graded_mul (am10_15_iii I m x) (am10_15_iii I n y) := by
  rcases x with ⟨x, hx⟩
  rcases y with ⟨y, hy⟩
  rfl

lemma am10_15_iv : (I.adicCompletion I) ≤ (⊥ : Ideal (AdicCompletion I A)).jacobson :=
  IsAdicComplete.le_jacobson_bot (I.adicCompletion I)
