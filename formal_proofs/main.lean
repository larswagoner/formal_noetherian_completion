import Mathlib


-- 7.5 Polynomial.isNoetherianRing

-- 7.6 


-- 10.5 completion of completion is completion



-- 10.13 

-- really this says its bijective, i guess an extra step is necessary for isomorphism. 
lemma am10_13_1  {R : Type u} [CommRing R] (I : Ideal R) (M : Type u) [AddCommGroup M] [Module R M] [IsNoetherianRing R] [Module.Finite R M] :
Function.Bijective ⇑(AdicCompletion.ofTensorProduct I M) := by

  exact AdicCompletion.ofTensorProduct_bijective_of_finite_of_isNoetherian I M

lemma am10_13_2  {R : Type u} [CommRing R] (I : Ideal R) (M : Type u) [AddCommGroup M] [Module R M] [IsNoetherianRing R] [Module.Finite R M] : TensorProduct R (AdicCompletion I R) ≃ₗ [AdicCompletion I R] AdicCompletion I R := by
  sorry

lemma am10_13 {A:Type*} [CommRing A] [hN : IsNoetherianRing A] (I : Ideal A) (M : Type*) [AddCommGroup M] [Module A M] [hM : Module.Finite A M] : TensorProduct A (AdicCompletion I A) M ≃ₗ[AdicCompletion I A] AdicCompletion I M := by
  sorry

-- 10.14 If A is a Noetherian Ring, I an ideal and A' the I-adic completion of A, then A' is a flat A-algebra

lemma am10_14 {A : Type*} [CommRing A] (I : Ideal A) [hN: IsNoetherianRing A] : Module.Flat A (AdicCompletion I A) := by 
  exact AdicCompletion.flat_of_isNoetherian I




-- 10.15.
  --i. If A is Noetherian, A' its I-adic completion, then I' = A' ⊗ I.
  -- use AdicCompletion.coe_ofTensorProductEquivOfFiniteNoetherian?
  -- is I' the I-adic completion of I as an A-module? or should i have it be the ideal of A' generated by I... Use I.map AdicCompletion.ofTensorProduct

variable {A: Type*} [CommRing A] (I : Ideal A) [hN : IsNoetherianRing A]


noncomputable def am10_15_i {R : Type*} [CommRing R] (I : Ideal R) [hN : IsNoetherianRing R] : 
  TensorProduct R (AdicCompletion I R) I ≃ₗ[AdicCompletion I R] AdicCompletion I I := by-- should be iso ≃ₗ[AdicCompletion I R]  instead of equality... but then its not a proposition
    exact AdicCompletion.ofTensorProductEquivOfFiniteNoetherian I ↥I




--ii. (I')^n = (I^n)'

-- iii. (I^n)/(I^n+1) ≃ₗ[A] I'^n/I'^n+1 


noncomputable def Ideal.adicCompletion (J : Ideal A): Ideal (AdicCompletion I A) := Ideal.map (algebraMap _ _) J -- extension of J into I-adic completion via induced algebra map.



noncomputable def adicQ (n : ℕ) : Type _ := (↥(I^n)⧸(I•⊤ : Submodule A ↥(I^n))) 
instance : AddCommGroup (adicQ I n) := inferInstanceAs (AddCommGroup (↥(I^n)⧸(I•⊤ : Submodule A ↥(I^n))))
noncomputable instance : AddCommGroup (adicQ (I.adicCompletion I) n) := inferInstanceAs (AddCommGroup (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))))


set_option synthInstance.maxHeartbeats 0
noncomputable def f : ↥(I.adicCompletion I ^ n) →ₗ[A] (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))) := (Submodule.mkQ (I.adicCompletion I • ⊤)).restrictScalars A

-- many ↥ makes it slow
noncomputable def am10_15_iii {n:ℕ } {A: Type*} [CommRing A] (I : Ideal A) [hN : IsNoetherianRing A] : 
    (↥(I^n)⧸(I•⊤ : Submodule A ↥(I^n))) → (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))) := by
    apply Submodule.liftQ (I•⊤ : Submodule A ↥(I^n)) f ?_ -- okay seems like sl in f is a problem... maybe try a different map. not submodule.liftq
    · let f : ↥(I.adicCompletion I ^ n) →ₗ[A] (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))) := (Submodule.mkQ (I.adicCompletion I • ⊤)).restrictScalars A
    
      let g : ↥(I^n) →ₗ[A] ↥((I.adicCompletion I)^n) := sorry
      refine f ∘ₗ g 
    · 
      sorry
     



--- second version, optimized but first refine statement doesnt type check.

-- many ↥ makes it slow
noncomputable def am10_15_iii2 {n:ℕ } {A: Type*} [CommRing A] (I : Ideal A) [hN : IsNoetherianRing A] : 
    (adicQ I n) → (adicQ (I.adicCompletion I) n) := by
    -- Be explicit about the module structure
    apply Submodule.liftQ ?_ ?_ ?_
    sorry

    /-refine Submodule.liftQ _ ?a ?b -- this error can be fixed by solving instance above
    · let f : ↥(I.adicCompletion I ^ n) →ₗ[A] (↥((I.adicCompletion I)^n) ⧸ ((I.adicCompletion I) • ⊤ : Submodule (AdicCompletion I A) ↥((I.adicCompletion I)^n))) := (Submodule.mkQ (I.adicCompletion I • ⊤)).restrictScalars A
    
      let g : ↥(I^n) →ₗ[A] ↥((I.adicCompletion I)^n) := sorry
      refine f ∘ₗ g 
    · 
      sorry
      -/
    





-- 10.22.i
-- inspiration GradedRing.GradeZero.isNoetherianRing

--lemma GradedRing.ofNoetherian.isNoetherian {A: Type*} [Ring A] [IsNoetherianRing A]


-- 10.25

-- 10.26
theorem AdicCompletion.ofNoetherianRing.isNoetherianRing {A : Type*} [CommRing A] (I : Ideal A) [h: IsNoetherianRing A] : IsNoetherianRing (AdicCompletion I A) := by
  sorry